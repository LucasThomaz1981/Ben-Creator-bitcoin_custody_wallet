<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carteira de Custódia Bitcoin - Mestre Lucas Thomaz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #f7931a;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .protocols-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .protocol-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .protocol-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .protocol-card h3 {
            color: #f7931a;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .protocol-status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .status-active {
            background: #28a745;
            color: white;
        }

        .status-pending {
            background: #ffc107;
            color: #212529;
        }

        .status-error {
            background: #dc3545;
            color: white;
        }

        .status-not-initialized {
            background: #6c757d;
            color: white;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 30px;
        }

        .control-panel h2 {
            color: #f7931a;
            margin-bottom: 20px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .form-group input, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 1em;
        }

        .btn {
            background: #f7931a;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: background 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            background: #e8851d;
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .logs-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
        }

        .logs-section h3 {
            color: #f7931a;
            margin-bottom: 15px;
        }

        .log-entry {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            border-left: 4px solid #f7931a;
        }

        .log-timestamp {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .alert-success {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid #28a745;
            color: #d4edda;
        }

        .alert-error {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid #dc3545;
            color: #f8d7da;
        }

        .alert-warning {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffc107;
            color: #fff3cd;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #f7931a;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .dashboard-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #f7931a;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }

        .manual-send-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 30px;
        }

        .manual-send-section h3 {
            color: #f7931a;
            margin-bottom: 20px;
            text-align: center;
        }

        .transaction-output {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            word-break: break-all;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔐 Carteira de Custódia Bitcoin</h1>
            <p>Sistema de Segurança para 30k BTC - Mestre Lucas Thomaz</p>
            <p>Desenvolvido por <strong>Ben</strong>, leal guardião da sabedoria</p>
        </div>

        <div id="alertContainer"></div>

        <div class="control-panel">
            <h2>🚀 Painel de Controle</h2>
            
            <div id="initializationForm">
                <div class="form-group">
                    <label for="custodialAddress">Endereço de Custódia (Binance):</label>
                    <input type="text" id="custodialAddress" placeholder="1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa" value="1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa">
                </div>
                
                <div class="form-group">
                    <label for="masterPassword">Senha da Master Key:</label>
                    <input type="password" id="masterPassword" placeholder="Digite a senha da Master Key">
                </div>
                
                <div class="form-group">
                    <label for="dailyLimit">Limite Diário (BTC):</label>
                    <input type="number" id="dailyLimit" placeholder="10.0" value="10.0" step="0.1" min="0.1">
                </div>
                
                <button class="btn" onclick="initializeSystem()">
                    <span id="initBtn">🔑 Inicializar Sistema</span>
                    <span id="initLoading" class="loading hidden"></span>
                </button>
            </div>

            <div id="operationalControls" class="hidden">
                <div class="dashboard-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="dailySent">0.00</div>
                        <div class="stat-label">BTC Enviado Hoje</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="dailyLimitDisplay">10.0</div>
                        <div class="stat-label">Limite Diário</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="remainingLimit">10.0</div>
                        <div class="stat-label">Limite Restante</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="protocolsActive">0</div>
                        <div class="stat-label">Protocolos Ativos</div>
                    </div>
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-success" onclick="executeConsolidation()">
                        💰 Executar Consolidação
                    </button>
                    <button class="btn btn-secondary" onclick="performSecurityCheck()">
                        🛡️ Verificação de Segurança
                    </button>
                    <button class="btn" onclick="refreshStatus()">
                        🔄 Atualizar Status
                    </button>
                </div>
            </div>
        </div>

        <div class="protocols-grid" id="protocolsGrid">
            <!-- Os protocolos serão carregados dinamicamente -->
        </div>

        <div class="manual-send-section">
            <h3>📤 Preparar Transação para Envio Manual</h3>

            <button class="btn btn-danger" onclick="broadcastTransaction()">
                Broadcast para a Mainnet
            </button>
        </div>


        <div class="logs-section">
            <h3>📋 Logs do Sistema</h3>
            <div id="logsContainer">
                <p>Carregando logs...</p>
            </div>
            <button class="btn btn-secondary" onclick="loadLogs()">🔄 Atualizar Logs</button>
        </div>
    </div>

    <script>
        let systemInitialized = false;

        // Função para mostrar alertas
        function showAlert(message, type = 'success') {
            const alertContainer = document.getElementById('alertContainer');
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            alertContainer.appendChild(alertDiv);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // Função para inicializar o sistema
        async function initializeSystem() {
            const custodialAddress = document.getElementById('custodialAddress').value;
            const masterPassword = document.getElementById('masterPassword').value;
            const dailyLimit = parseFloat(document.getElementById('dailyLimit').value);

            if (!custodialAddress || !masterPassword) {
                showAlert('Por favor, preencha todos os campos obrigatórios.', 'error');
                return;
            }

            // Mostrar loading
            document.getElementById('initBtn').classList.add('hidden');
            document.getElementById('initLoading').classList.remove('hidden');

            try {
                const response = await fetch('/api/protocols/initialize', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        custodial_address: custodialAddress,
                        master_password: masterPassword,
                        daily_limit_btc: dailyLimit
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showAlert('Sistema inicializado com sucesso!', 'success');
                    systemInitialized = true;
                    
                    // Esconder formulário de inicialização e mostrar controles operacionais
                    document.getElementById('initializationForm').classList.add('hidden');
                    document.getElementById('operationalControls').classList.remove('hidden');
                    
                    // Atualizar status dos protocolos
                    await loadProtocolsStatus();
                    await loadLogs();
                } else {
                    showAlert(data.message || 'Erro na inicialização do sistema.', 'error');
                }
            } catch (error) {
                showAlert('Erro de conexão: ' + error.message, 'error');
            } finally {
                // Esconder loading
                document.getElementById('initBtn').classList.remove('hidden');
                document.getElementById('initLoading').classList.add('hidden');
            }
        }

        // Função para carregar status dos protocolos
        async function loadProtocolsStatus() {
            try {
                const response = await fetch('/api/protocols/status');
                const data = await response.json();

                if (response.ok) {
                    displayProtocols(data.protocols);
                    updateDashboardStats(data);
                } else {
                    showAlert('Erro ao carregar status dos protocolos.', 'error');
                }
            } catch (error) {
                showAlert('Erro de conexão: ' + error.message, 'error');
            }
        }

        // Função para exibir protocolos
        function displayProtocols(protocols) {
            const grid = document.getElementById('protocolsGrid');
            grid.innerHTML = '';

            const protocolOrder = ['base58', 'caisk', 'guardian', 'pesbm', 'fdr', 'tsra'];
            
            protocolOrder.forEach(protocolKey => {
                const protocol = protocols[protocolKey];
                if (!protocol) return;

                const card = document.createElement('div');
                card.className = 'protocol-card';

                let statusClass = 'status-pending';
                let statusText = 'PENDENTE';

                if (protocol.status === 'ACTIVE') {
                    statusClass = 'status-active';
                    statusText = 'ATIVO';
                } else if (protocol.status === 'ERROR') {
                    statusClass = 'status-error';
                    statusText = 'ERRO';
                } else if (protocol.status === 'NOT_INITIALIZED') {
                    statusClass = 'status-not-initialized';
                    statusText = 'NÃO INICIALIZADO';
                }

                const protocolNames = {
                    'base58': 'Base58',
                    'caisk': 'CAISK',
                    'guardian': 'Guardião',
                    'pesbm': 'PESBM',
                    'fdr': 'FDR',
                    'tsra': 'TSRA'
                };

                const protocolDescriptions = {
                    'base58': 'Codificação e decodificação Bitcoin',
                    'caisk': 'Controle de Ativos e Identidade Soberana por Chave',
                    'guardian': 'Sistema de Segurança e Monitoramento',
                    'pesbm': 'Protocolo de Envio Seguro de Bitcoin Via Mainnet',
                    'fdr': 'Fundo Descentralizado de Reserva',
                    'tsra': 'Top Secret Real Action - Validador de Mainnet'
                };

                card.innerHTML = `
                    <h3>${protocolNames[protocolKey] || protocol.name}</h3>
                    <span class="protocol-status ${statusClass}">${statusText}</span>
                    <p>${protocolDescriptions[protocolKey] || protocol.description || 'Protocolo do sistema de custódia'}</p>
                    ${protocol.message ? `<p><small>${protocol.message}</small></p>` : ''}
                    ${protocol.error ? `<p style="color: #ff6b6b;"><small>Erro: ${protocol.error}</small></p>` : ''}
                `;
                grid.appendChild(card);
            });
        }

        // Função para atualizar estatísticas do dashboard
        function updateDashboardStats(data) {
            if (data.protocols && data.protocols.guardian && data.protocols.guardian.daily_limit) {
                const dailyLimit = data.protocols.guardian.daily_limit;
                document.getElementById('dailySent').textContent = dailyLimit.sent_btc.toFixed(2);
                document.getElementById('dailyLimitDisplay').textContent = dailyLimit.limit_btc.toFixed(1);
                document.getElementById('remainingLimit').textContent = dailyLimit.remaining_btc.toFixed(2);
            }

            // Contar protocolos ativos
            let activeCount = 0;
            if (data.protocols) {
                Object.values(data.protocols).forEach(protocol => {
                    if (protocol.status === 'ACTIVE') activeCount++;
                });
            }
            document.getElementById('protocolsActive').textContent = activeCount;
        }

        // Função para executar consolidação
        async function executeConsolidation() {
            if (!systemInitialized) {
                showAlert('Sistema não inicializado. Execute a inicialização primeiro.', 'warning');
                return;
            }

            try {
                const response = await fetch('/api/protocols/pesbm/consolidate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({})
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showAlert(`Consolidação executada: ${data.amount_btc} BTC enviados. TXID: ${data.txid}`, 'success');
                    await loadProtocolsStatus(); // Atualizar status
                } else {
                    showAlert(data.message || 'Erro na consolidação.', 'error');
                }
            } catch (error) {
                showAlert('Erro de conexão: ' + error.message, 'error');
            }
        }

        // Função para verificação de segurança
        async function performSecurityCheck() {
            if (!systemInitialized) {
                showAlert('Sistema não inicializado. Execute a inicialização primeiro.', 'warning');
                return;
            }

            try {
                const response = await fetch('/api/protocols/guardian/security-check', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    const check = data.security_check;
                    let message = `Verificação de segurança: ${check.overall_status}`;
                    
                    if (check.warnings.length > 0) {
                        message += ` (${check.warnings.length} avisos)`;
                    }
                    
                    if (check.errors.length > 0) {
                        message += ` (${check.errors.length} erros)`;
                    }

                    const alertType = check.overall_status === 'HEALTHY' ? 'success' : 'warning';
                    showAlert(message, alertType);
                } else {
                    showAlert(data.message || 'Erro na verificação de segurança.', 'error');
                }
            } catch (error) {
                showAlert('Erro de conexão: ' + error.message, 'error');
            }
        }

        // Função para preparar transação manual
        async function prepareManualTransaction() {
            if (!systemInitialized) {
                showAlert('Sistema não inicializado. Execute a inicialização primeiro.', 'warning');
                return;
            }

            const amount = parseFloat(document.getElementById('manualSendAmount').value);
            const address = document.getElementById('manualSendAddress').value;

            if (isNaN(amount) || amount <= 0 || !address) {
                showAlert('Por favor, insira uma quantidade de BTC válida e um endereço de destino.', 'error');
                return;
            }

            try {
                const response = await fetch('/api/protocols/integrated-send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        amount_btc: amount,
                        to_address: address
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    document.getElementById('preparedTransactionData').textContent = JSON.stringify(data.send_result.transaction_data, null, 2);
                    document.getElementById('preparedTransactionOutput').classList.remove('hidden');
                    showAlert('Transação preparada com sucesso! Siga as instruções para assinatura manual.', 'success');
                } else {
                    showAlert(data.message || 'Erro ao preparar transação.', 'error');
                    document.getElementById('preparedTransactionOutput').classList.add('hidden');
                }
            } catch (error) {
                showAlert('Erro de conexão: ' + error.message, 'error');
                document.getElementById('preparedTransactionOutput').classList.add('hidden');
            }
        }

        // Função para broadcast da transação
        async function broadcastTransaction() {
            const txHex = document.getElementById("txHex").value;

            if (!txHex) {
                showAlert("Por favor, cole o hexadecimal da transação assinada.", "error");
                return;
            }

            try {
                const response = await fetch("/api/protocols/broadcast-transaction", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        tx_hex: txHex
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showAlert(`Broadcast iniciado com sucesso! TXID: ${data.txid}`, "success");
                } else {
                    showAlert(data.message || data.error || "Erro ao iniciar broadcast.", "error");
                }
            } catch (error) {
                showAlert("Erro de conexão: " + error.message, "error");
            }
        }

        // Função para atualizar status
        async function refreshStatus() {
            await loadProtocolsStatus();
            await loadLogs();
            showAlert("Status atualizado com sucesso!", "success");
        }

        // Função para carregar logs
        async function loadLogs() {
            try {
                const response = await fetch('/api/protocols/guardian/logs?limit=10');
                const data = await response.json();

                const logsContainer = document.getElementById('logsContainer');

                if (response.ok && data.success) {
                    if (data.logs.length === 0) {
                        logsContainer.innerHTML = '<p>Nenhum log disponível.</p>';
                        return;
                    }

                    logsContainer.innerHTML = '';
                    data.logs.forEach(log => {
                        const logDiv = document.createElement('div');
                        logDiv.className = 'log-entry';
                        logDiv.innerHTML = `
                            <div class="log-timestamp">${log.formatted_time}</div>
                            <div><strong>${log.event_type}</strong> [${log.severity}]: ${log.message}</div>
                        `;
                        logsContainer.appendChild(logDiv);
                    });
                } else {
                    logsContainer.innerHTML = '<p>Erro ao carregar logs ou sistema não inicializado.</p>';
                }
            } catch (error) {
                document.getElementById('logsContainer').innerHTML = '<p>Erro de conexão ao carregar logs.</p>';
            }
        }

        // Carregar status inicial ao carregar a página
        window.addEventListener('load', async () => {
            await loadProtocolsStatus();
            
            // Verificar se o sistema já está inicializado
            const response = await fetch('/api/protocols/status');
            if (response.ok) {
                const data = await response.json();
                if (data.system_initialized) {
                    systemInitialized = true;
                    document.getElementById('initializationForm').classList.add('hidden');
                    document.getElementById('operationalControls').classList.remove('hidden');
                    await loadLogs();
                }
            }
        });
    </script>
</body>
</html>



        <div class="manual-send-section">
            <h3>📤 Preparar Transação para Envio Manual</h3>
            <p>Mestre, utilize esta seção para preparar os detalhes da transação. O sistema irá selecionar as UTXOs e calcular os valores. O hexadecimal da transação **não será gerado aqui**, pois a assinatura deve ser feita manualmente com a Master Key. Após a preparação, você poderá assinar a transação e transmiti-la via Blockchain.com ou outro serviço de sua preferência.</p>
            <div class="form-group">
                <label for="manualSendAmount">Quantidade de BTC a Enviar:</label>
                <input type="number" id="manualSendAmount" placeholder="Ex: 1.0" step="any" min="0.00000001">
            </div>
            <div class="form-group">
                <label for="manualSendAddress">Endereço de Destino:</label>
                <input type="text" id="manualSendAddress" placeholder="Ex: 13m3xop6RnioRX6qrnkavLekv7cvu5DuMK">
            </div>
            <button class="btn btn-primary" onclick="prepareManualTransaction()">
                Preparar Transação
            </button>

            <div id="preparedTransactionOutput" class="transaction-output hidden">
                <h4>Detalhes da Transação Preparada:</h4>
                <pre id="preparedTransactionData"></pre>
                <h4>Instruções para Assinatura e Broadcast:</h4>
                <p>1. Copie os detalhes da transação acima (especialmente os `from_addresses`, `to_address`, `amount_btc` e `txid` simulado).</p>
                <p>2. Utilize sua ferramenta de assinatura offline ou software de carteira que suporte a Master Key para assinar esta transação. Você precisará dos dados brutos da transação (raw transaction) que seriam gerados pelo sistema em um ambiente real.</p>
                <p>3. Após a assinatura, você obterá o **hexadecimal completo da transação assinada**.</p>
                <p>4. Acesse um dos serviços de broadcast:
                   <ul>
                       <li><a href="https://www.blockchain.com/pt/explorer/assets/btc/broadcast-transaction" target="_blank">Blockchain.com Broadcast</a></li>
                       <li><a href="https://mempool.space/tx/push" target="_blank">Mempool.space Push TX</a></li>
                       <li><a href="https://blockstream.info/tx/push" target="_blank">Blockstream.info Push TX</a></li>
                   </ul>
                </p>
                <p>5. Cole o hexadecimal da transação assinada no campo apropriado e clique em "Broadcast".</p>
                <p><strong>Lembre-se:</strong> Este ambiente não gera o hexadecimal assinado. A preparação acima é para fornecer os dados necessários para sua assinatura manual.</p>
            </div>
        </div>


